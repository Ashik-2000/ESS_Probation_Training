ngOnInit(){} --> Gets called every time the component get re-rendered. Components re-renders when a variable gets changed by value.
ngOnChanges(changes: simpleChanges){} --> Get called every time any variable of that changes either by value or by reference. Only one with a parameter.
ngDoCheck(){} --> Called whenever Angular checks for any changes.
ngAfterContentInit(){} --> After <ng-content> initialized.
ngViewInit(){} --> After ngAfterContentInit() gets called.
ngAfterContentChecked(){} --> After ngDoCheck() gets called.
ngAfterViewChecked(){} --> After ngAfterContentChecked gets called.
ngOnDestroy(){} --> Gets called after anything gets, destroyed or removed from the DOM.


Observale Operators:
.pipe() -> Method is to use operator.

Creation operator:
of -> The 'of' function allows us to create an Observable, which emits a set of values and completes. So, when we subscribe to such Observable, 
all values that we have provided as arguments will be emitted immediately as next notifications, and then, the Observable will complete, ending the Subscription.

from -> it can convert an array into an Observable. It works the same way as the 'of' creation function, however, in the case of 'from', you provide an array 
with the values instead of providing multiple arguments. Another popular usage of 'from' is to create an Observable from Promise. Once we subscribe to such
Observable, the Promise's resolve value will be emitted as a next notification and then it will complete. If the Promise gets rejected, the Observable will 
emit an error notification. 'from' can also create Observables from other sources, like iterables (generator functions) and other Observable-like objects.

forkJoin -> Accepts an array of observables as input. After all these Observables complete, it emits a set of latest values emitted by each of them and it 
emits after all the observables are complete. Useful if you need to wait for the result of a couple of HTTP calls. If any of the input observables fails the 
other ones get cancelled too, and emits error.

combineLatest -> accepts an array of input Observables, to which it subscribes underneath, but contrary to 'forkJoin', the combineLatest's logic will emit a 
new set of values each time any of the input Observables emits something new. If any of the input observables fails the  other ones get cancelled too. and 
emits error.

pipe Operators:
map() -> Receives individual item of a iterable
flatMap
switchMap
mergeMap
exhaustMap
takeUntil
filter
debounceTime
distinct
tap() -> Receives event
delay
finalize
retry
catchError() -> Receives error




Folder Structure:
src/
└── app/
    ├── components/
    │   ├── header/
    │   │   ├── header.component.ts
    │   │   ├── header.component.html
    │   │   └── header.component.css
    │   ├── orders-list/
    │   │   ├── orders-list.component.ts
    │   │   ├── orders-list.component.html
    │   │   └── orders-list.component.css
    │   ├── order-form/
    │   │   ├── order-form.component.ts
    │   │   ├── order-form.component.html
    │   │   └── order-form.component.css
    │   └── not-found/
    │       ├── not-found.component.ts
    │       ├── not-found.component.html
    │       └── not-found.component.css
	│
	├── data/
    │   └── db.json
	│
	├── interfaces/
	│	└── interfaces.ts
	│
	├── services/
    │   ├── customer.service.ts
    │   ├── order.service.ts
	│	└── product.service.ts
	│
    ├── app-routing.module.ts
    ├── app.component.ts
    ├── app.component.html
    ├── app.component.css
    └── app.module.ts




requirements:
Objective:
Build a Sales Order Management module using Angular 14. The goal is to demonstrate
your understanding of Angular fundamentals, Reactive Forms, and data handling.
	-> View a paginated, searchable, and sortable list of sales orders.
	-> Create and update sales orders with VAT, discount, and calculated totals.
	-> Manage customers (existing, new, or guest).
	
Functional Requirements
1. Sales Order List Page
	-> Display sales orders with Order No, Customer, Date, Total, and Status.
	-> Support search, filter, sorting, and pagination.
	-> Each action should update URL query parameters and call API with a paginated
		DTO:
		{
		"page": 1,
		"pageSize": 10,
		"sortBy": "orderDate",
		"sortDir": "desc",
		"search": "john",
		"filters": { "status": "Completed" }
		}
		

2. Sales Order Form (Create / Edit)
	-> Use Reactive Forms with proper validation.
	-> Sections:
		-> Customer Info: Select existing, add new, or guest customer.
		-> Order Items: Add multiple products (Product, Qty, Unit Price).
		-> Auto-calculation:
			> Line Total = Quantity × Unit Price
			> VAT (e.g., 15%)
			> Discount (%)
			> Grand Total = Σ(Line Totals) + VAT - Discount
	-> Buttons: Save / Update / Cancel
	-> Show mock save result as JSON or console log.
	

API / Data Simulation

Use mock API endpoints (e.g., json-server ):
	GET /api/orders
	POST /api/orders
	PUT /api/orders/:id
	GET /api/customers
	POST /api/customers
	GET /api/products

Example Order Object:
	{
	"id": 101,
	"orderNo": "SO-2025-001",
	"customer": { "id": 1, "name": "John Doe" },
	"items": [
	{ "product": "Laptop", "qty": 2, "price": 800, "vat": 15, "discount": 5 }
	],
	"total": 1520,
	"status": "Completed"
	}
	
Additional Requirements
	Use Angular Routing for navigation:
		/orders → Sales Orders List
		/orders/new → Create Order
		/orders/:id/edit → Edit Order
	Show validation errors and prevent submission of invalid forms.
	Handle 404 (invalid route) gracefully.
	Clean UI and responsive layout.


Reactive-Form:

orderForm
├── customer (FormGroup)
│    ├── id
│    └── name
├── items (FormArray)
│    ├── [0]
│    │     ├── product
│    │     ├── qty
│    │     ├── price
│    │     └── lineTotal
├── vat
├── discount
├── total
├── status
├── date
